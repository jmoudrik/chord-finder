import math
import warnings
from itertools import ifilter, imap, islice


class ToneSystem:
	def __init__(self, scalesize, base_tones, modificators, chord_masks):
		def unroll_lazy(l):
			out=[]
			for f,s in l:
				if isinstance(f,list):
					for ff in f:
						out.append((ff,s))
				else:
					out.append((f,s))
			return out
		def get_dicts(list_of_pairs):
			d = {}
			d_inv = {}
			for key, val in list_of_pairs:
				# one key should have ONLY one val
				if key in d:
					assert d[key] == val
				d[key] = val
				# make inverse dict, if one value has more keys, take the first one
				if val not in d_inv:
					d_inv[val] = key
			return d, d_inv
		def fill_in_rest_of_t2l(t2l, d2m):
			def nbhood():
				for d in xrange(1, int(math.ceil(scalesize / 2.0))):
					yield d
					yield -d
			rest = {}
			for tone in ifilter(lambda x: x not in t2l, xrange(scalesize)):
				for diff in nbhood():
					try:
						rest[tone] = t2l[(tone - diff)%scalesize] + d2m[diff]
						break
					except KeyError:
						pass
			return rest

		self.scalesize = scalesize
		self.l2t, self.t2l = get_dicts(unroll_lazy(base_tones))
		self.m2d, self.d2m = get_dicts(unroll_lazy(modificators))
		self.chsuff2mask, self.mask2chsuff = get_dicts(unroll_lazy(chord_masks))

		# fills in labels using X from modif in firstround, ev XX in second, ...
		while len(set(xrange(scalesize)) - set(self.t2l.keys())) > 0:
			rest = fill_in_rest_of_t2l(self.t2l,self.d2m)
			if len(rest) == 0:
				warnings.warn("The given tonal system is not complete. With given modificators, it is not possible to name all the tones..")
				break
			self.t2l.update(rest)

		self.init_parsing()

	def init_parsing(self):
		from pyparsing import CaselessLiteral, OneOrMore, Or, ZeroOrMore, Empty

		def get_parsers_pairs(pa_fc, projdict):
			return [ (CaselessLiteral(label) if len(label) > 0 else Empty()).setParseAction( pa_fc(val) )\
												for label, val  in projdict.iteritems() ]

		def num_tok(num):
			def pa(st, locn, toks):
				return num
			return pa

		def pa_sum(st, locn, toks):
			return sum(toks) % self.scalesize

		self.p_modi = OneOrMore(Or(get_parsers_pairs(num_tok, self.m2d)))
		self.p_tone = Or(imap( lambda x: (x + ZeroOrMore(self.p_modi)).setParseAction(pa_sum), get_parsers_pairs(num_tok, self.l2t)))
		self.p_chord_modi = Or(get_parsers_pairs(num_tok, self.chsuff2mask))

		def pach(st, locn, toks):
			assert len(toks) == 2
			return self.shift_mask(toks[0], toks[1])
		self.p_chord = (self.p_tone + self.p_chord_modi).setParseAction(pach)

	def tone_to_label(self, tone):
		return self.t2l[tone % self.scalesize]
	def label_to_tone(self, label):
		toks = self.p_tone.parseString(label)
		assert len(toks) == 1
		return toks[0]
	def map_mask(self, fc, mask):
		return tuple(sorted(imap(lambda x : fc(x) % self.scalesize, mask)))
	def shift_mask(self, shift, mask):
		return self.map_mask(lambda x : x + shift, mask)
	def mask_to_base_n_chmask(self, mask):
		for basetone in mask:
			chmask = self.shift_mask( - basetone, mask)
			if chmask in self.mask2chsuff:
				yield basetone, chmask
	def mask_to_chordname(self, mask):
		basetone, chmask = self.mask_to_base_n_chmask(mask).next()
		return self.tone_to_label(basetone) + self.mask2chsuff[chmask]
	def chordname_to_mask(self, label):
		toks = self.p_chord.parseString(label)
		assert len(toks) == 1
		return toks[0]
	def test(t):
		print t.label_to_tone("Bbb")
		print t.label_to_tone("Fisisis")
		print t.label_to_tone("Gis")

		for ch in [ "Bismaj7", "Cmaj7", "Fisisissus6", "Gis5+" ]:
			m = t.chordname_to_mask(ch)
			ch2 = t.mask_to_chordname(m)
			m2 = t.chordname_to_mask(ch2)
			print " -> ".join(imap(lambda x: str(x), [ch,m,ch2,m2]))

		for bt,msk in t.mask_to_base_n_chmask((0,4,8)):
			print t.tone_to_label(bt),t.mask_to_chordname(msk)

class ChordEvaluator:
	EvalFcs=[]
	def evalfc(f):
		#EvalFcs.append(f)
		return f
	@evalfc
	def no_none(ch,gr):
		if not None in ch:
			return 1
		return 0
	@evalfc
	def none_in_middle(ch,gr):
		return reduce(lambda x,y: x + 1 if y == None else 0, ch)

#	none_down
#	none_up
#	small_width
#	num_of_fingers
#	dve sousedni struny hraji ten samy ton (A 5 & D 0) - pze rozladena kytara pak zni hnusne

class Instrument:
	def __init__(self, strings, tone_system, num_frets):
		'''
		strings is a tuple, from the bottommost,
			e.g. for a guitar
			strings = ('E','H','G','D','A','E')
			e.g. for a bass guitar
			strings = ('G','D','A','E')
		'''
		self.ts = tone_system
		self.string_names = strings
		self.strings = tuple(imap(tone_system.label_to_tone, strings))
		self.num_frets = num_frets
	def get_fretboard(self):
		return [ set((fr,(zerofret + fr) % self.ts.scalesize) for fr in xrange(self.num_frets + 1)) for zerofret in self.strings]
	def filter_fretboard_by_chordmask(self, fretboard, mask):
		return [ set(ifilter(lambda pair: pair[1] in mask, st)) for st in fretboard ]
	def tone(self, string, fret):
		if fret == None:
			fret = 0
		return (self.strings[string] + fret) % self.ts.scalesize
	def search(self, mask, max_chord_span=3):
		# filter out tones that are not in chord
		fretboard = self.filter_fretboard_by_chordmask(self.get_fretboard(), mask )

		def dfs(chords_res, rest_of_tones, chordsofar=(), chordspan=(self.num_frets, 0), string=0):
			if string >= len(self.strings):
				if len(rest_of_tones) == 0:
					chords_res.append(chordsofar)
				return
			for fret, tone in fretboard[string] | set(((None,None),)):
				minfret, maxfret = chordspan
				# we want such chords that do not span across more then 3 (or self.max_chord_span) frets
				# no one has hand that wide... :-)
				if fret > 0:
					if fret > minfret and fret - minfret > max_chord_span: continue
					if fret < maxfret and maxfret - fret > max_chord_span: continue
					if fret < minfret: minfret = fret
					if fret > maxfret: maxfret = fret
				responsible=set((tone,)) & rest_of_tones
				rest_of_tones -= responsible
				dfs(chords_res, rest_of_tones, chordsofar + ((string,fret),), (minfret, maxfret), string+1)
				rest_of_tones |= responsible

		chords_res = []
		rest_of_tones = set(mask)
		dfs(chords_res, rest_of_tones)
		print "guiseppe"
		self.find_grips(chords_res[0])
		return chords_res

		grips = map(self.find_grips, chords_res)

		chords_n_grips=[]
		for ch, grips in zip(chords_res, grips):
			for grip in grips:
				chords_n_grips.append((ch, grip))

		return chords_n_grips
	def find_grips(self, chord):
		print "ch", chord
		chord = filter(lambda x: x[1] != None, chord)
		by_frets={}
		for string, fr in chord:
			by_frets.setdefault(fr, []).append(string)
		print by_frets
		frets_list=[]
		for fr, l in by_frets.iteritems():
			l.sort(reverse=True)
			frets_list.append((fr, l))
		frets_list.sort()
		if len(frets_list) == 0:
			return []
		results=[]

		assignment=[]
		index = 0
		index_fret = 0
		if frets_list[0][0] == 0:
			for string in frets_list[0][1]:
				assignment.append((string, None))
			index += 1

		#search
		if index >= len(frets_list) == 0:
			results.append(tuple(sorted(assignment)))
		if len(frets_list[index][1]) == 0:
			index += 1

		print frets_list

		# TODO: extend results (string, None)

		return []
	def chord_str(self, chord):
		# TODO
		return str(chord)
	def evaluator(self, chord):
		return 1.0
	def find_and_evaluate_chords(self, mask):
		chord_candidates = self.search(mask)
		chords_sorted = map(lambda p: p[1],sorted(zip(imap(self.evaluator, chord_candidates), chord_candidates), reverse=True))
		for num, chord in enumerate(islice(chords_sorted,3)):
			print num, self.chord_str(chord)


base_tones = [('C',0),('D',2),('E',4),('F',5),('G',7),('A',9),('B',10),('H',11)]
tone_modificators = [('#',1), ('b',-1), ('is',1), ('es', -1)]
chord_masks = [('',(0,4,7)),(['mi','m'],(0,3,7)),(['5+','+','aug'],(0,4,8)),('sus4',(0,5,7)),(['6','sus6','add6'],(0,4,7,9)),\
				(['maj','maj7'],(0,4,7,11))]

t = ToneSystem(12, base_tones, tone_modificators, chord_masks)
#t.test()
i = Instrument(('E','H','G','D','A','E'),t,8)
i.find_and_evaluate_chords(t.chordname_to_mask('G'))

